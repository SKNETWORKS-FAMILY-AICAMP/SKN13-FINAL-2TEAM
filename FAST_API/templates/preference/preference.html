{% extends "base.html" %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', path='css/preference.css') }}">
{% endblock %}

{% block content %}
<div class="preference-container">
    <div class="card-stack-container" id="card-stack">
        {% for item in recommended_items %}
        <div class="preference-card" data-product-id="{{ item.get('상품ID') }}">
            <img class="card-image" src="{{ item.get('사진') or item.get('대표이미지URL', 'https://via.placeholder.com/150') }}" alt="{{ item['제품이름'] }}">
            <div class="card-info">
                <h3 class="card-title">{{ item['제품이름'] }}</h3>
                <p class="card-brand">{{ item['브랜드'] }}</p>
            </div>
            <!-- Feedback Overlays -->
            <div class="card-feedback like">LIKE</div>
            <div class="card-feedback dislike">NOPE</div>
        </div>
        {% endfor %}
    </div>

        <div class="action-buttons">
        <button class="action-btn like-btn" id="like-btn">💚</button>
        <button class="action-btn dislike-btn" id="dislike-btn">❌</button>
    </div>

    <div class="no-more-cards" id="no-more-cards" style="display: none;">
        <p>더 이상 추천할 상품이 없습니다.</p>
        <button id="refresh-cards-btn" class="refresh-btn">새로운 상품 불러오기</button>
    </div>
</div>

</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const stack = document.getElementById('card-stack');
        let cards = Array.from(stack.querySelectorAll('.preference-card')).reverse();
        const likeBtn = document.getElementById('like-btn');
        const dislikeBtn = document.getElementById('dislike-btn');
        const noMoreCardsDiv = document.getElementById('no-more-cards');
        const refreshCardsBtn = document.getElementById('refresh-cards-btn');

        let activeCard = null;

        function setupCards() {
            console.log('setupCards called. Initial cards.length:', cards.length);
            if (cards.length === 0) {
                console.log('No cards initially, showing noMoreCardsDiv.');
                noMoreCardsDiv.style.display = 'block';
                return;
            }
            // Temporarily remove this line to see if it's ever visible
            // noMoreCardsDiv.style.display = 'none';

            cards.forEach((card, index) => {
                const zIndex = index + 1;
                const depthEffect = (cards.length - 1) - index;

                gsap.set(card, {
                    y: 0,
                    scale: 1 - depthEffect * 0.04,
                    opacity: 1 - depthEffect * 0.1,
                    filter: `blur(${depthEffect * 2}px)`,
                    zIndex: zIndex,
                });

                Draggable.create(card, {
                    type: 'x,y',
                    edgeResistance: 0.65,
                    bounds: 'body',
                    onDragStart: function() {
                        gsap.to(this.target, { filter: 'blur(0px)', duration: 0.2 });
                    },
                    onDragEnd: async function() { // Make async to await sendJjim
                        if (Math.abs(this.x) > 100) {
                            const direction = this.x > 0 ? 1 : -1;
                            if (direction === -1) { // This is a "like" swipe
                                const pid = this.target.getAttribute('data-product-id');
                                if (pid) await sendJjim(pid);
                            }
                            swipeCard(this.target, direction);
                        } else {
                            gsap.to(this.target, { x: 0, y: 0, rotation: 0, filter: 'blur(0px)', duration: 0.4, ease: 'power2.out' });
                            gsap.set(this.target, { zIndex: cards.length });
                        }
                    },
                    onDrag: function() {
                        const rotation = this.x * 0.1;
                        const likeFeedback = this.target.querySelector('.like');
                        const dislikeFeedback = this.target.querySelector('.dislike');

                        gsap.to(likeFeedback, { opacity: -this.x / 100, duration: 0.1 });
                        gsap.to(dislikeFeedback, { opacity: this.x / 100, duration: 0.1 });
                        gsap.to(this.target, { rotation: rotation, duration: 0.1 });
                    }
                });
            });
            activeCard = cards[cards.length - 1];
        }

        function swipeCard(card, direction) {
            const rotation = direction * 45;
            const feedbackEl = direction > 0 ? card.querySelector('.dislike') : card.querySelector('.like');

            gsap.to(feedbackEl, { opacity: 1, duration: 0.4 });

            gsap.to(card, {
                x: direction * 400,
                rotation: rotation,
                opacity: 0,
                duration: 0.5,
                ease: 'power1.in',
                onComplete: () => {
                    console.log('Swipe animation complete.');
                    // Ensure the card is removed from the DOM
                    if (card.parentNode) { // Check if it still has a parent
                        card.parentNode.removeChild(card);
                        console.log('Card removed from DOM.');
                    } else {
                        console.log('Card already removed from DOM.');
                    }

                    // Destroy the Draggable instance for this card
                    const draggableInstance = Draggable.get(card);
                    if (draggableInstance) {
                        draggableInstance.kill(); // Destroy the Draggable instance
                        console.log('Draggable instance killed.');
                    }

                    cards.pop();
                    console.log('Card popped from array. New cards.length:', cards.length);
                    activeCard = cards.length > 0 ? cards[cards.length - 1] : null;
                    reorganizeStack();
                    console.log('Checking for last card. Current cards.length:', cards.length);
                    if (cards.length === 0) {
                        console.log('All cards processed. Showing noMoreCardsDiv.');
                        noMoreCardsDiv.style.display = 'block';
                        console.log('noMoreCardsDiv display after setting:', noMoreCardsDiv.style.display);
                    }
                }
            });
        }

        function reorganizeStack() {
            cards.forEach((card, index) => {
                const zIndex = index + 1;
                const depthEffect = (cards.length - 1) - index;

                gsap.to(card, {
                    y: 0,
                    scale: 1 - depthEffect * 0.04,
                    opacity: 1 - depthEffect * 0.1,
                    filter: `blur(${depthEffect * 2}px)`,
                    duration: 0.4,
                    ease: 'power2.out',
                    onStart: () => gsap.set(card, { zIndex: zIndex })
                });
            });
        }

        async function sendJjim(productId) {
            try {
                const fd = new FormData();
                fd.append('product_id', productId);
                await fetch('/preference/jjim', { method: 'POST', body: fd });
            } catch (e) { console.error(e); }
        }

        likeBtn.addEventListener('click', async () => {
            if (activeCard) {
                const pid = activeCard.getAttribute('data-product-id');
                if (pid) await sendJjim(pid);
                swipeCard(activeCard, -1);
            }
        });

        dislikeBtn.addEventListener('click', () => {
            if (activeCard) swipeCard(activeCard, 1);
        });

        refreshCardsBtn.addEventListener('click', async () => {
            console.log('Refresh button clicked.');
            noMoreCardsDiv.style.display = 'none';
            try {
                const response = await fetch('/preference/api/items');
                if (!response.ok) throw new Error('Failed to fetch new items');
                const newItems = await response.json();

                if (newItems.length > 0) {
                    stack.innerHTML = ''; // Clear existing cards
                    newItems.forEach(item => {
                        const cardHtml = `
                            <div class="preference-card" data-product-id="${item.상품ID}">
                                <img class="card-image" src="${item.사진 || item.대표이미지URL || 'https://via.placeholder.com/150'}" alt="${item.상품명}">
                                <div class="card-info">
                                    <h3 class="card-title">${item.상품명}</h3>
                                    <p class="card-brand">${item.브랜드}</p>
                                </div>
                                <div class="card-feedback like">LIKE</div>
                                <div class="card-feedback dislike">NOPE</div>
                            </div>
                        `;
                        stack.insertAdjacentHTML('beforeend', cardHtml);
                    });
                    cards = Array.from(stack.querySelectorAll('.preference-card')).reverse();
                    setupCards(); // Re-initialize Draggable for new cards
                } else {
                    noMoreCardsDiv.style.display = 'block'; // Show message if no new items
                    noMoreCardsDiv.querySelector('p').textContent = '더 이상 불러올 상품이 없습니다.';
                    refreshCardsBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('Error refreshing cards:', error);
                alert('새로운 상품을 불러오는 데 실패했습니다.');
            }
        });

        // GSAP Draggable 플러그인 로드 확인
        if (typeof Draggable === 'undefined') {
            const draggableScript = document.createElement('script');
            draggableScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js?v=1';
            document.head.appendChild(draggableScript);
            draggableScript.onload = setupCards;
        } else {
            setupCards();
        }
    });
</script>
{% endblock %}
