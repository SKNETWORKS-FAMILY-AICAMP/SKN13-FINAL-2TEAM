{% extends "base.html" %}

{% block head %}
<link rel="stylesheet" href="https://43.201.185.192/static/css/preference.css">
<link rel="stylesheet" href="https://43.201.185.192/static/css/preference_custom.css">
{% endblock %}

{% block content %}
<div class="preference-container">
    <div class="card-stack-container" id="card-stack">
        {% for item in recommended_items %}
        <div class="preference-card" 
             data-product-id="{{ item.get('ìƒí’ˆì½”ë“œ') }}"
             data-product-name="{{ item.get('ìƒí’ˆëª…') }}"
             data-product-brand="{{ item.get('í•œê¸€ë¸Œëœë“œëª…') }}"
             data-product-category="{{ item.get('ëŒ€ë¶„ë¥˜') }}"
             data-product-subcategory="{{ item.get('ì†Œë¶„ë¥˜') }}"
             data-product-color="{{ item.get('ìƒ‰ìƒ') }}"
             data-product-price="{{ item.get('ì›ê°€') }}"
             data-product-image="{{ item.get('ì‚¬ì§„') or item.get('ëŒ€í‘œì´ë¯¸ì§€URL') }}"
             data-product-link="{{ item.get('ìƒí’ˆë§í¬') }}"
             data-product-site="{{ item.get('ì‚¬ì´íŠ¸ëª…') }}">
            <img class="card-image" src="{{ item.get('ì‚¬ì§„') or item.get('ëŒ€í‘œì´ë¯¸ì§€URL', 'https://via.placeholder.com/150') }}" alt="{{ item['ìƒí’ˆëª…'] }}">
            <div class="card-info">
                <h3 class="card-title">{{ item['ìƒí’ˆëª…'] }}</h3>
                <p class="card-brand">{{ item['í•œê¸€ë¸Œëœë“œëª…'] }}</p>
            </div>
            <!-- Feedback Overlays -->
            <div class="card-feedback like">LIKE</div>
            <div class="card-feedback dislike">NOPE</div>
        </div>
        {% endfor %}
        <div id="no-more-products-message" class="preference-message-container">
            <p>ğŸ˜” ë” ì´ìƒ ì¶”ì²œí•  ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.</p>
            <button id="load-new-products-button" class="preference-load-button">ìƒˆë¡œìš´ ìƒí’ˆ ë¶ˆëŸ¬ì˜¤ê¸°</button>
        </div>
    </div>

        <div class="action-buttons">
        <button class="action-btn like-btn" id="like-btn">ğŸ’š</button>
        <button class="action-btn dislike-btn" id="dislike-btn">âŒ</button>
    </div>

    
</div>

</div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const stack = document.getElementById('card-stack');
        let cards = Array.from(stack.querySelectorAll('.preference-card')).reverse();
        const likeBtn = document.getElementById('like-btn');
        const dislikeBtn = document.getElementById('dislike-btn');
        const noMoreCardsDiv = document.getElementById('no-more-products-message');
        const refreshCardsBtn = document.getElementById('load-new-products-button');

        let activeCard = null;

        function setupCards() {
            console.log('setupCards called. Current cards.length:', cards.length);
            if (cards.length === 0) {
                console.log('No cards. Showing noMoreCardsDiv. Button display:', refreshCardsBtn.style.display);
                noMoreCardsDiv.classList.add('show');
                refreshCardsBtn.style.display = 'block'; // Add this line
                noMoreCardsDiv.querySelector('p').textContent = 'ğŸ˜” ë” ì´ìƒ ì¶”ì²œí•  ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.'; // Ensure correct message
                return;
            }
            // Temporarily remove this line to see if it's ever visible
            // noMoreCardsDiv.classList.remove('show');

            cards.forEach((card, index) => {
                const zIndex = index + 1;
                const depthEffect = (cards.length - 1) - index;

                gsap.set(card, {
                    y: 0,
                    scale: 1 - depthEffect * 0.04,
                    opacity: 1 - depthEffect * 0.1,
                    filter: `blur(${depthEffect * 2}px)`,
                    zIndex: zIndex,
                });

                Draggable.create(card, {
                    type: 'x,y',
                    edgeResistance: 0.65,
                    bounds: 'body',
                    onDragStart: function() {
                        gsap.to(this.target, { filter: 'blur(0px)', duration: 0.2 });
                    },
                    onDragEnd: async function() { // Make async to await sendJjim
                        if (Math.abs(this.x) > 100) {
                            const direction = this.x > 0 ? 1 : -1;
                            if (direction === -1) { // This is a "like" swipe
                                const pid = this.target.getAttribute('data-product-id');
                                if (pid) await sendJjim(pid);
                            }
                            swipeCard(this.target, direction);
                        } else {
                            gsap.to(this.target, { x: 0, y: 0, rotation: 0, filter: 'blur(0px)', duration: 0.4, ease: 'power2.out' });
                            gsap.set(this.target, { zIndex: cards.length });
                        }
                    },
                    onDrag: function() {
                        const rotation = this.x * 0.1;
                        const likeFeedback = this.target.querySelector('.like');
                        const dislikeFeedback = this.target.querySelector('.dislike');

                        gsap.to(likeFeedback, { opacity: -this.x / 100, duration: 0.1 });
                        gsap.to(dislikeFeedback, { opacity: this.x / 100, duration: 0.1 });
                        gsap.to(this.target, { rotation: rotation, duration: 0.1 });
                    }
                });
            });
            activeCard = cards[cards.length - 1];
        }

        function swipeCard(card, direction) {
            const rotation = direction * 45;
            const feedbackEl = direction > 0 ? card.querySelector('.dislike') : card.querySelector('.like');

            gsap.to(feedbackEl, { opacity: 1, duration: 0.4 });

            gsap.to(card, {
                x: direction * 400,
                rotation: rotation,
                opacity: 0,
                duration: 0.5,
                ease: 'power1.in',
                onComplete: () => {
                    console.log('Swipe animation complete.');
                    // Ensure the card is removed from the DOM
                    if (card.parentNode) { // Check if it still has a parent
                        card.parentNode.removeChild(card);
                        console.log('Card removed from DOM.');
                    } else {
                        console.log('Card already removed from DOM.');
                    }

                    // Destroy the Draggable instance for this card
                    const draggableInstance = Draggable.get(card);
                    if (draggableInstance) {
                        draggableInstance.kill(); // Destroy the Draggable instance
                        console.log('Draggable instance killed.');
                    }

                    console.log('GSAP animation onComplete. Before cards.pop(), cards.length:', cards.length);
                    cards.pop();
                    console.log('After cards.pop(), cards.length:', cards.length);
                    console.log('Card swiped. Remaining cards:', cards.length);
                    activeCard = cards.length > 0 ? cards[cards.length - 1] : null;
                    reorganizeStack();
                    console.log('Checking for last card. Current cards.length:', cards.length);
                    console.log('Checking if cards.length is 0:', cards.length === 0);
                    if (cards.length === 0) {
                        console.log('Attempting to show noMoreCardsDiv from swipeCard.');
                        console.log('All cards exhausted. Showing noMoreCardsDiv. Button display:', refreshCardsBtn.style.display);
                        noMoreCardsDiv.classList.add('show');
                        refreshCardsBtn.style.display = 'block'; // Add this line
                        noMoreCardsDiv.querySelector('p').textContent = 'ğŸ˜” ë” ì´ìƒ ì¶”ì²œí•  ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.'; // Ensure correct message
                        console.log('noMoreCardsDiv display after setting:', noMoreCardsDiv.style.display);
                    }
                }
            });
        }

        function reorganizeStack() {
            cards.forEach((card, index) => {
                const zIndex = index + 1;
                const depthEffect = (cards.length - 1) - index;

                gsap.to(card, {
                    y: 0,
                    scale: 1 - depthEffect * 0.04,
                    opacity: 1 - depthEffect * 0.1,
                    filter: `blur(${depthEffect * 2}px)`,
                    duration: 0.4,
                    ease: 'power2.out',
                    onStart: () => gsap.set(card, { zIndex: zIndex })
                });
            });
        }

        async function sendJjim(productId) {
            try {
                const fd = new FormData();
                fd.append('product_id', productId);
                await fetch('/preference/jjim', { method: 'POST', body: fd });
            } catch (e) { console.error(e); }
        }

        likeBtn.addEventListener('click', async () => {
            if (activeCard) {
                const pid = activeCard.getAttribute('data-product-id');
                if (pid) await sendJjim(pid);
                swipeCard(activeCard, -1);
            }
        });

        dislikeBtn.addEventListener('click', () => {
            if (activeCard) swipeCard(activeCard, 1);
        });

        refreshCardsBtn.addEventListener('click', async () => {
            console.log('Refresh button clicked. Hiding noMoreCardsDiv.');
            noMoreCardsDiv.classList.remove('show');
            console.log('Fetching new items...');
            try {
                const response = await fetch('/preference/api/items');
                console.log('Response status:', response.status);
                if (!response.ok) throw new Error('Failed to fetch new items');
                const newItems = await response.json();
                console.log('newItems.length:', newItems.length);

                if (newItems.length > 0) {
                    console.log('New items found. Clearing stack and setting up new cards.');
                    // noMoreCardsDivë¥¼ ì„ì‹œë¡œ DOM ë°–ìœ¼ë¡œ ì˜®ê¹ë‹ˆë‹¤.
                    const preferenceContainer = document.querySelector('.preference-container');
                    preferenceContainer.appendChild(noMoreCardsDiv);

                    stack.innerHTML = ''; // ê¸°ì¡´ ì¹´ë“œë“¤ì„ ì§€ì›ë‹ˆë‹¤.

                    newItems.forEach(item => {
                        const cardHtml = `
                            <div class="preference-card" data-product-id="${item.ìƒí’ˆì½”ë“œ}">
                                <img class="card-image" src="${item.ì‚¬ì§„ || item.ëŒ€í‘œì´ë¯¸ì§€URL || 'https://via.placeholder.com/150'}" alt="${item.ìƒí’ˆëª…}">
                                <div class="card-info">
                                    <h3 class="card-title">${item.ìƒí’ˆëª…}</h3>
                                    <p class="card-brand">${item.í•œê¸€ë¸Œëœë“œëª…}</p>
                                </div>
                                <div class="card-feedback like">LIKE</div>
                                <div class="card-feedback dislike">NOPE</div>
                            </div>
                        `;
                        stack.insertAdjacentHTML('beforeend', cardHtml);
                    });

                    // noMoreCardsDivë¥¼ ë‹¤ì‹œ stack ì•ˆìœ¼ë¡œ ì˜®ê¹ë‹ˆë‹¤.
                    stack.appendChild(noMoreCardsDiv);

                    cards = Array.from(stack.querySelectorAll('.preference-card')).reverse();
                    setupCards(); // Re-initialize Draggable for new cards
                    refreshCardsBtn.style.display = 'block'; // Ensure button is visible
                    noMoreCardsDiv.querySelector('p').textContent = 'ğŸ˜” ë” ì´ìƒ ì¶”ì²œí•  ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.'; // Reset message text
                    console.log('noMoreCardsDiv text reset. Button display:', refreshCardsBtn.style.display);
                } else {
                    console.log('No new items found. Showing noMoreCardsDiv with "no more to load" message.');
                    noMoreCardsDiv.classList.add('show'); // Show message if no new items
                    noMoreCardsDiv.querySelector('p').textContent = 'ë” ì´ìƒ ë¶ˆëŸ¬ì˜¬ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤.';
                    refreshCardsBtn.style.display = 'none';
                    console.log('Button display:', refreshCardsBtn.style.display);
                }
            } catch (error) {
                console.error('Error refreshing cards:', error);
                alert('ìƒˆë¡œìš´ ìƒí’ˆì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        });

        // GSAP Draggable í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ í™•ì¸
        if (typeof Draggable === 'undefined') {
            const draggableScript = document.createElement('script');
            draggableScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js?v=1';
            document.head.appendChild(draggableScript);
            draggableScript.onload = setupCards;
        } else {
            setupCards();
        }
    });
</script>
{% endblock %}
